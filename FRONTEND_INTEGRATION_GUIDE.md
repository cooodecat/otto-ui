# 🎯 Frontend Integration Guide

Otto 백엔드 로그 수집 시스템과 프론트엔드 연동 가이드입니다.

## 📋 현재 구현된 백엔드 시스템

### 🏗️ 아키텍처 개요

백엔드에서는 CloudWatch Logs API를 활용한 **3단계 로그 처리 파이프라인**을 구현했습니다:

1. **수집 단계**: 5초마다 CloudWatch API를 호출하여 새로운 로그 수집
2. **캐싱 단계**: 서버 메모리에 빌드별로 최근 1000개 로그 저장
3. **스트리밍 단계**: Server-Sent Events(SSE)로 실시간 전달

### 🔧 핵심 기능

- **주기적 로그 수집**: setInterval로 5초 간격 자동 수집
- **상태 관리**: 빌드별 수집 상태, 페이지네이션 토큰 관리
- **메모리 최적화**: 순환 버퍼로 최신 1000개 로그만 유지
- **실시간 전달**: 새 로그 수집 즉시 SSE로 브로드캐스트

### 🛠️ 제공되는 API

| 기능          | 엔드포인트                             | 용도                     |
| ------------- | -------------------------------------- | ------------------------ |
| 수집 시작     | `POST /logs/builds/{id}/start`         | 특정 빌드 로그 수집 시작 |
| 수집 중지     | `POST /logs/builds/{id}/stop`          | 로그 수집 중지           |
| 전체 조회     | `GET /logs/builds/{id}`                | 캐시된 모든 로그 조회    |
| 최근 조회     | `GET /logs/builds/{id}/recent?limit=N` | 최근 N개 로그만 조회     |
| 실시간 스트림 | `GET /logs/builds/{id}/stream`         | SSE 실시간 스트림        |
| 상태 확인     | `GET /logs/builds/{id}/status`         | 수집 활성화 여부 확인    |

## 🎯 프론트엔드 구현 전략

### 📝 단계별 구현 가이드

#### 1단계: 기본 로그 화면 만들기

**목표**: 기존 로그를 화면에 표시하는 기본 컴포넌트 구현

**구현 방법**:

- 로그 컨테이너(스크롤 가능한 영역) 생성
- 빌드 ID를 받아서 `/recent` API로 최근 로그 가져오기
- 로그 배열을 화면에 렌더링 (시간 + 메시지 형식)

**핵심 포인트**:

- 터미널처럼 검은 배경에 흰 글씨로 표시하면 직관적
- 자동 스크롤 기능으로 최신 로그가 항상 보이게 설정

#### 2단계: 실시간 업데이트 추가

**목표**: Server-Sent Events로 실시간 로그 받기

**구현 방법**:

- `EventSource`를 사용해서 `/stream` 엔드포인트에 연결
- 새로운 로그가 오면 기존 로그 배열에 추가
- 상태로 연결 여부 표시 (🟢 연결됨 / 🔴 끊어짐)

**핵심 포인트**:

- 컴포넌트 언마운트 시 연결 정리하기
- 연결이 끊어지면 자동으로 재연결 시도

#### 3단계: 로그 수집 제어

**목표**: 로그 수집 시작/중지 기능 추가

**구현 방법**:

- "로그 수집 시작" 버튼으로 `/start` API 호출
- "중지" 버튼으로 `/stop` API 호출 및 SSE 연결 종료
- `/status` API로 현재 수집 상태 확인

**핵심 포인트**:

- 버튼 상태를 수집 여부에 따라 활성화/비활성화
- 로딩 상태 표시로 사용자 경험 개선

---

## 🛠️ 구현 시 주의사항

### 💡 성능 최적화 팁

#### 메모리 관리

- **문제**: 로그가 계속 쌓여서 브라우저 메모리 부족
- **해결**: 화면에 표시할 로그 개수 제한 (예: 최근 500개만)
- **방법**: 배열 크기 체크해서 오래된 로그 제거

#### 렌더링 최적화

- **문제**: 로그가 많아지면 화면 업데이트가 느려짐
- **해결**: 가상화(virtualization) 라이브러리 사용
- **추천**: `react-window` 또는 `react-virtualized` 사용

#### 네트워크 효율성

- **초기 로딩**: 전체 로그 대신 `/recent?limit=100` 사용
- **실시간**: SSE로 새 로그만 받아서 추가
- **필터링**: 서버에서 하지 말고 프론트에서 처리

### 🔧 기술 선택 가이드

#### SSE vs WebSocket

**SSE 선택 이유**:

- 서버에서 클라이언트로만 데이터 전송 (로그는 단방향)
- HTTP 기반이라 프록시, 방화벽 통과 쉬움
- 브라우저에서 자동 재연결 지원

**구현 팁**:

- `EventSource` 객체 사용
- 연결 상태 모니터링으로 UX 개선
- 오류 시 지수 백오프로 재연결

#### 상태 관리

**간단한 프로젝트**: `useState` + `useEffect`만으로 충분
**복잡한 프로젝트**: Redux, Zustand 등으로 전역 상태 관리

### 🎨 UI/UX 권장사항

#### 터미널 스타일 디자인

- **배경**: 검은색 또는 어두운 회색
- **글씨**: 흰색 또는 연한 회색
- **폰트**: 고정폭 폰트 (Consolas, Monaco 등)
- **크기**: 작은 글씨로 많은 내용 표시

#### 로그 레벨별 색상 구분

- **ERROR**: 빨간색 (심각한 오류)
- **WARN**: 노란색 (경고)
- **INFO**: 파란색 (일반 정보)
- **DEBUG**: 회색 (디버그 정보)

#### 사용자 편의 기능

- **자동 스크롤**: 새 로그 오면 자동으로 하단 이동
- **스크롤 고정**: 사용자가 위로 스크롤하면 자동 스크롤 멈춤
- **검색/필터**: 키워드로 로그 필터링
- **다운로드**: 로그를 텍스트 파일로 저장

---

## 🚀 빠른 시작 가이드

### React 프로젝트 기준

#### 1. 기본 컴포넌트 구조

```
LogViewer/
├── index.jsx          // 메인 컴포넌트
├── LogEntry.jsx       // 개별 로그 표시
├── LogControls.jsx    // 시작/중지 버튼
└── styles.css         // 터미널 스타일
```

#### 2. 필요한 Hook들

- `useState`: 로그 데이터, 연결 상태 관리
- `useEffect`: 컴포넌트 마운트 시 SSE 연결
- `useRef`: EventSource 객체 참조 유지

#### 3. 구현 순서

1. **정적 화면**: 더미 데이터로 로그 목록 표시
2. **API 연동**: 실제 로그 데이터 가져오기
3. **실시간**: SSE 연결해서 새 로그 받기
4. **제어**: 시작/중지 버튼 기능 추가
5. **개선**: 검색, 필터, 다운로드 등 부가 기능

## 🎨 실제 구현 시 고려사항

### 💭 구현 우선순위

#### 1. MVP (최소 기능 제품)

- **필수**: 로그 목록 표시 + 실시간 업데이트
- **기간**: 1-2일
- **복잡도**: 낮음

#### 2. 기본 기능 완성

- **추가**: 시작/중지 버튼 + 상태 표시
- **기간**: +1일
- **복잡도**: 중간

#### 3. 사용성 개선

- **추가**: 검색, 필터, 다운로드
- **기간**: +2-3일
- **복잡도**: 중간

### 🚨 자주 발생하는 문제들

#### 메모리 누수 문제

**증상**: 시간이 지나면서 브라우저가 느려짐
**원인**: 로그가 계속 쌓여서 메모리 부족
**해결**: 화면에 표시할 로그 개수 제한

#### SSE 연결 불안정

**증상**: 로그가 중간중간 끊어짐
**원인**: 네트워크 불안정 또는 서버 재시작
**해결**: 자동 재연결 로직 구현 (3초 후 재시도)

#### 렌더링 성능 저하

**증상**: 로그가 많아지면 화면이 버벅임
**원인**: DOM 요소가 너무 많아짐
**해결**: 가상화 라이브러리 사용

### 🛡️ 오류 처리 전략

#### 네트워크 오류

- **API 호출 실패**: 사용자에게 알림 메시지 표시
- **SSE 연결 끊김**: 자동 재연결 + 상태 표시
- **타임아웃**: 재시도 로직 구현

#### 데이터 오류

- **빈 응답**: 기본 메시지 표시 ("로그가 없습니다")
- **잘못된 형식**: 콘솔에 오류 로그, 사용자에게는 숨김
- **권한 오류**: 명확한 안내 메시지

### 📱 반응형 디자인 고려사항

#### 모바일 환경

- **터치 스크롤**: 스크롤 영역 충분히 크게
- **글씨 크기**: 모바일에서도 읽기 쉽게 조정
- **버튼 크기**: 터치하기 쉬운 크기로 설정

#### 다양한 화면 크기

- **가로 스크롤 방지**: 긴 로그 메시지는 줄바꿈
- **유연한 높이**: 화면 크기에 따라 로그 영역 높이 조정

---

## 📚 API 레퍼런스

### 🔗 주요 엔드포인트

| 목적          | 메소드 | URL                                             | 응답        |
| ------------- | ------ | ----------------------------------------------- | ----------- |
| 수집 시작     | `POST` | `/api/v1/logs/builds/{buildId}/start`           | 성공 메시지 |
| 수집 중지     | `POST` | `/api/v1/logs/builds/{buildId}/stop`            | 성공 메시지 |
| 로그 조회     | `GET`  | `/api/v1/logs/builds/{buildId}/recent?limit=50` | 로그 배열   |
| 실시간 스트림 | `GET`  | `/api/v1/logs/builds/{buildId}/stream`          | SSE 스트림  |

### 📄 데이터 형식

**로그 이벤트 구조**:

```json
{
  "timestamp": 1694851200000,
  "message": "[INFO] Build completed successfully",
  "ingestionTime": 1694851200000
}
```

**SSE 이벤트 구조**:

```json
{
  "buildId": "otto-codebuild-project:12345",
  "events": [
    /* 로그 이벤트 배열 */
  ],
  "timestamp": 1694851200000
}
```

---

## 🆘 문제 해결 가이드

### 자주 묻는 질문

#### Q. "로그가 실시간으로 안 와요"

**확인사항**:

1. 로그 수집이 시작되었나? → `/status` API로 확인
2. SSE 연결이 되었나? → 브라우저 개발자 도구 Network 탭 확인
3. 실제로 새 로그가 있나? → CloudWatch에서 직접 확인

#### Q. "브라우저가 점점 느려져요"

**해결방법**:

1. 화면에 표시할 로그 개수 제한 (500-1000개)
2. 오래된 로그 배열에서 제거
3. `react-window` 같은 가상화 라이브러리 사용

#### Q. "연결이 자주 끊어져요"

**대응방법**:

1. 재연결 로직 구현 (3초 후 재시도)
2. 연결 상태 UI로 표시
3. 네트워크 환경 확인 (프록시, 방화벽 등)

### 개발 팁

#### 디버깅

- 브라우저 개발자 도구에서 SSE 연결 상태 모니터링
- 콘솔에서 API 응답 확인
- 백엔드 로그에서 수집 상태 확인

#### 테스트

- 먼저 하드코딩된 buildId로 테스트
- 로그 수집 시작 후 실제 빌드 실행해서 확인
- 다양한 브라우저에서 SSE 호환성 테스트

---

## 🎯 구현 체크리스트

### 1단계: 기본 구현

- [ ] 로그 목록 화면 만들기
- [ ] `/recent` API로 기존 로그 가져오기
- [ ] 터미널 스타일 CSS 적용

### 2단계: 실시간 기능

- [ ] EventSource로 SSE 연결
- [ ] 새 로그 받아서 화면에 추가
- [ ] 자동 스크롤 구현

### 3단계: 제어 기능

- [ ] 시작/중지 버튼 추가
- [ ] 연결 상태 표시
- [ ] 오류 처리 및 재연결

### 4단계: 사용성 개선

- [ ] 로그 검색/필터 기능
- [ ] 로그 다운로드 기능
- [ ] 반응형 디자인 적용

---

## 🚀 마무리

이 가이드를 따라하면 **약 3-5일** 내에 완전한 로그 뷰어를 구현할 수 있습니다.

**추천 개발 순서**:

1. 정적 화면부터 시작 (더미 데이터)
2. API 연동으로 실제 데이터 표시
3. SSE로 실시간 업데이트 구현
4. 제어 기능 및 오류 처리 추가

**성공 포인트**:

- 단계별로 나누어서 구현
- 각 단계마다 충분한 테스트
- 사용자 경험 우선 고려
